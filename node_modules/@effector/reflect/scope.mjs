import * as effectorReactSSR from 'effector-react/scope';
import { is, scopeBind } from 'effector';
import { useProvidedScope } from 'effector-react';
import React from 'react';

function reflectCreateFactory(context) {
  const reflect = reflectFactory(context);
  return function createReflect(view) {
    return (bind, params) => reflect({
      view,
      bind,
      ...params
    });
  };
}
function reflectFactory(context) {
  return function reflect(config) {
    const {
      stores,
      events,
      data,
      functions
    } = sortProps(config.bind);
    const hooks = sortProps(config.hooks || {});
    return /*#__PURE__*/React.forwardRef((props, ref) => {
      const storeProps = context.useUnit(stores, config.useUnitConfig);
      const eventsProps = context.useUnit(events, config.useUnitConfig);
      const functionProps = useBoundFunctions(functions);
      const finalProps = {};
      if (ref) {
        finalProps.ref = ref;
      }
      const elementProps = Object.assign(finalProps, storeProps, eventsProps, data, functionProps, props);
      const eventsHooks = context.useUnit(hooks.events, config.useUnitConfig);
      const functionsHooks = useBoundFunctions(hooks.functions);
      React.useEffect(() => {
        const hooks = Object.assign({}, functionsHooks, eventsHooks);
        if (hooks.mounted) {
          hooks.mounted(elementProps);
        }
        return () => {
          if (hooks.unmounted) {
            hooks.unmounted(elementProps);
          }
        };
      }, [eventsHooks, functionsHooks]);
      return /*#__PURE__*/React.createElement(config.view, elementProps);
    });
  };
}
function sortProps(props) {
  const events = {};
  const stores = {};
  const data = {};
  const functions = {};
  for (const key in props) {
    const value = props[key];
    if (is.event(value) || is.effect(value)) {
      events[key] = value;
    } else if (is.store(value)) {
      stores[key] = value;
    } else if (typeof value === 'function') {
      functions[key] = value;
    } else {
      data[key] = value;
    }
  }
  return {
    events,
    stores,
    data,
    functions
  };
}
function useBoundFunctions(functions) {
  const scope = useProvidedScope();
  return React.useMemo(() => {
    const boundFunctions = {};
    for (const key in functions) {
      const fn = functions[key];
      boundFunctions[key] = scopeBind(fn, {
        scope: scope || undefined,
        safe: true
      });
    }
    return boundFunctions;
  }, [scope, functions]);
}

const Default = () => null;
function variantFactory(context) {
  const reflect = reflectFactory(context);
  return function variant(config) {
    let $case;
    let cases;
    let def;
    // Shortcut for Store<boolean>
    if ('if' in config) {
      $case = config.if.map(value => value ? 'then' : 'else');
      cases = {
        then: config.then,
        else: config.else
      };
      def = Default;
    }
    // Full form for Store<string>
    else {
      $case = config.source;
      cases = config.cases;
      def = config.default ?? Default;
    }
    function View(props) {
      const nameOfCase = context.useUnit($case, config.useUnitConfig);
      const Component = cases[nameOfCase] ?? def;
      return /*#__PURE__*/React.createElement(Component, props);
    }
    const bind = config.bind ?? {};
    return reflect({
      bind,
      view: View,
      hooks: config.hooks,
      useUnitConfig: config.useUnitConfig
    });
  };
}

function listFactory(context) {
  const reflect = reflectFactory(context);
  return function list(config) {
    const ItemView = reflect({
      view: config.view,
      bind: config.bind ? config.bind : {},
      hooks: config.hooks,
      useUnitConfig: config.useUnitConfig
    });
    const listConfig = {
      getKey: config.getKey,
      fn: (value, index) => {
        const scope = useProvidedScope();
        const finalProps = React.useMemo(() => {
          const props = {};
          if (config.mapItem) {
            forIn(config.mapItem, prop => {
              const fn =
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              config.mapItem[prop];
              const propValue = fn(value, index);
              if (typeof propValue === 'function') {
                props[prop] = scopeBind(propValue, {
                  safe: true,
                  scope: scope || undefined
                });
              } else {
                props[prop] = propValue;
              }
            });
          } else {
            forIn(value, prop => {
              props[prop] = value[prop];
            });
          }
          return props;
        }, [value, index]);
        return /*#__PURE__*/React.createElement(ItemView, finalProps);
      }
    };
    return () => context.useList(config.source, listConfig);
  };
}
function forIn(target, fn) {
  const hasProp = {}.hasOwnProperty;
  for (const prop in target) {
    if (hasProp.call(target, prop)) fn(prop);
  }
}

console.error('`@effector/reflect/scope` is deprecated, use main `@effector/reflect` package instead');
const reflect = reflectFactory(effectorReactSSR);
const createReflect = reflectCreateFactory(effectorReactSSR);
const variant = variantFactory(effectorReactSSR);
const list = listFactory(effectorReactSSR);

export { createReflect, list, reflect, variant };
//# sourceMappingURL=scope.mjs.map
