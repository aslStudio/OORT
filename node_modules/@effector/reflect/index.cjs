'use strict';

var context = require('effector-react');
var effector = require('effector');
var React = require('react');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    for (var k in e) {
      n[k] = e[k];
    }
  }
  n.default = e;
  return n;
}

var context__namespace = /*#__PURE__*/_interopNamespaceDefault(context);

function reflectCreateFactory(context) {
  const reflect = reflectFactory(context);
  return function createReflect(view) {
    return (bind, params) => reflect({
      view,
      bind,
      ...params
    });
  };
}
function reflectFactory(context) {
  return function reflect(config) {
    const {
      stores,
      events,
      data,
      functions
    } = sortProps(config.bind);
    const hooks = sortProps(config.hooks || {});
    return /*#__PURE__*/React.forwardRef((props, ref) => {
      const storeProps = context.useUnit(stores, config.useUnitConfig);
      const eventsProps = context.useUnit(events, config.useUnitConfig);
      const functionProps = useBoundFunctions(functions);
      const finalProps = {};
      if (ref) {
        finalProps.ref = ref;
      }
      const elementProps = Object.assign(finalProps, storeProps, eventsProps, data, functionProps, props);
      const eventsHooks = context.useUnit(hooks.events, config.useUnitConfig);
      const functionsHooks = useBoundFunctions(hooks.functions);
      React.useEffect(() => {
        const hooks = Object.assign({}, functionsHooks, eventsHooks);
        if (hooks.mounted) {
          hooks.mounted(elementProps);
        }
        return () => {
          if (hooks.unmounted) {
            hooks.unmounted(elementProps);
          }
        };
      }, [eventsHooks, functionsHooks]);
      return /*#__PURE__*/React.createElement(config.view, elementProps);
    });
  };
}
function sortProps(props) {
  const events = {};
  const stores = {};
  const data = {};
  const functions = {};
  for (const key in props) {
    const value = props[key];
    if (effector.is.event(value) || effector.is.effect(value)) {
      events[key] = value;
    } else if (effector.is.store(value)) {
      stores[key] = value;
    } else if (typeof value === 'function') {
      functions[key] = value;
    } else {
      data[key] = value;
    }
  }
  return {
    events,
    stores,
    data,
    functions
  };
}
function useBoundFunctions(functions) {
  const scope = context.useProvidedScope();
  return React.useMemo(() => {
    const boundFunctions = {};
    for (const key in functions) {
      const fn = functions[key];
      boundFunctions[key] = effector.scopeBind(fn, {
        scope: scope || undefined,
        safe: true
      });
    }
    return boundFunctions;
  }, [scope, functions]);
}

const Default = () => null;
function variantFactory(context) {
  const reflect = reflectFactory(context);
  return function variant(config) {
    let $case;
    let cases;
    let def;
    // Shortcut for Store<boolean>
    if ('if' in config) {
      $case = config.if.map(value => value ? 'then' : 'else');
      cases = {
        then: config.then,
        else: config.else
      };
      def = Default;
    }
    // Full form for Store<string>
    else {
      $case = config.source;
      cases = config.cases;
      def = config.default ?? Default;
    }
    function View(props) {
      const nameOfCase = context.useUnit($case, config.useUnitConfig);
      const Component = cases[nameOfCase] ?? def;
      return /*#__PURE__*/React.createElement(Component, props);
    }
    const bind = config.bind ?? {};
    return reflect({
      bind,
      view: View,
      hooks: config.hooks,
      useUnitConfig: config.useUnitConfig
    });
  };
}

function listFactory(context$1) {
  const reflect = reflectFactory(context$1);
  return function list(config) {
    const ItemView = reflect({
      view: config.view,
      bind: config.bind ? config.bind : {},
      hooks: config.hooks,
      useUnitConfig: config.useUnitConfig
    });
    const listConfig = {
      getKey: config.getKey,
      fn: (value, index) => {
        const scope = context.useProvidedScope();
        const finalProps = React.useMemo(() => {
          const props = {};
          if (config.mapItem) {
            forIn(config.mapItem, prop => {
              const fn =
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              config.mapItem[prop];
              const propValue = fn(value, index);
              if (typeof propValue === 'function') {
                props[prop] = effector.scopeBind(propValue, {
                  safe: true,
                  scope: scope || undefined
                });
              } else {
                props[prop] = propValue;
              }
            });
          } else {
            forIn(value, prop => {
              props[prop] = value[prop];
            });
          }
          return props;
        }, [value, index]);
        return /*#__PURE__*/React.createElement(ItemView, finalProps);
      }
    };
    return () => context$1.useList(config.source, listConfig);
  };
}
function forIn(target, fn) {
  const hasProp = {}.hasOwnProperty;
  for (const prop in target) {
    if (hasProp.call(target, prop)) fn(prop);
  }
}

function fromTag(htmlTag) {
  return props => {
    return /*#__PURE__*/React.createElement(htmlTag, props);
  };
}

const reflect = reflectFactory(context__namespace);
const createReflect = reflectCreateFactory(context__namespace);
const variant = variantFactory(context__namespace);
const list = listFactory(context__namespace);

exports.createReflect = createReflect;
exports.fromTag = fromTag;
exports.list = list;
exports.reflect = reflect;
exports.variant = variant;
//# sourceMappingURL=index.cjs.map
